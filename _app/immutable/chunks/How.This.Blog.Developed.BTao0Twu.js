import{s as k,f as H,h as z,e as _,a as g,c as p,g as v,b as x,l as S,i as o,n as q,d as r}from"./scheduler.Z0-R3Vox.js";import{S as G,i as B,c as F,a as O,m as j,t as D,b as I,d as P}from"./index.BsQ1K1nZ.js";import{g as E,a as M}from"./spread.CgU5AtxT.js";import{M as K}from"./mdsvex.nDJp90hy.js";function A(h){let e,f="Contents",u,s,i='<li><a href="#general">General</a></li> <li><a href="#optimizations">Optimizations</a></li>',l,n,T="General",C,d,L="<li></li> <li>Built using SvelteKit</li>",b,m,$="Optimizations",w,c,y=`<li>Enable pre-render</li> <li>Unlike other SSGs, prerendered SvelteKit still allows for client-side hydration, so I can still use smooth client-side routing and transitions.</li> <li>Use static adapter</li> <li>For images, use AVIF / WebP instead of PNG / JPEG
<ul><li>Use Sveltekit <a href="https://kit.svelte.dev/docs/images#sveltejs-enhanced-img-srcset-and-sizes" rel="nofollow">enhanced:img</a></li></ul></li> <li>Optimize fonts by reducing their size
<ul><li>Only import the necessary weights and subsets for each font</li> <li>use woff2 files</li> <li>For hosting fonts, Fontsource can be used</li></ul></li> <li>Use inline CSS
<ul><li>It eliminates the need for an extra request to fetch an external CSS file</li> <li>However, it prevents the browser from caching the CSS file</li> <li>So while the initial load time can be faster, subsequent navigations may be slower.</li> <li>This is a worthy trade-off for blog pages where initial load time is much more important</li></ul></li>`;return{c(){e=_("h2"),e.textContent=f,u=g(),s=_("ul"),s.innerHTML=i,l=g(),n=_("h2"),n.textContent=T,C=g(),d=_("ul"),d.innerHTML=L,b=g(),m=_("h2"),m.textContent=$,w=g(),c=_("ul"),c.innerHTML=y,this.h()},l(t){e=p(t,"H2",{id:!0,"data-svelte-h":!0}),v(e)!=="svelte-mkui86"&&(e.textContent=f),u=x(t),s=p(t,"UL",{"data-svelte-h":!0}),v(s)!=="svelte-14rvix0"&&(s.innerHTML=i),l=x(t),n=p(t,"H2",{id:!0,"data-svelte-h":!0}),v(n)!=="svelte-gqtcke"&&(n.textContent=T),C=x(t),d=p(t,"UL",{"data-svelte-h":!0}),v(d)!=="svelte-1xuqwqv"&&(d.innerHTML=L),b=x(t),m=p(t,"H2",{id:!0,"data-svelte-h":!0}),v(m)!=="svelte-110rbje"&&(m.textContent=$),w=x(t),c=p(t,"UL",{"data-svelte-h":!0}),v(c)!=="svelte-1rrbfwg"&&(c.innerHTML=y),this.h()},h(){S(e,"id","contents"),S(n,"id","general"),S(m,"id","optimizations")},m(t,a){o(t,e,a),o(t,u,a),o(t,s,a),o(t,l,a),o(t,n,a),o(t,C,a),o(t,d,a),o(t,b,a),o(t,m,a),o(t,w,a),o(t,c,a)},p:q,d(t){t&&(r(e),r(u),r(s),r(l),r(n),r(C),r(d),r(b),r(m),r(w),r(c))}}}function J(h){let e,f;const u=[h[0],U];let s={$$slots:{default:[A]},$$scope:{ctx:h}};for(let i=0;i<u.length;i+=1)s=H(s,u[i]);return e=new K({props:s}),{c(){F(e.$$.fragment)},l(i){O(e.$$.fragment,i)},m(i,l){j(e,i,l),f=!0},p(i,[l]){const n=l&1?E(u,[l&1&&M(i[0]),l&0&&M(U)]):{};l&2&&(n.$$scope={dirty:l,ctx:i}),e.$set(n)},i(i){f||(D(e.$$.fragment,i),f=!0)},o(i){I(e.$$.fragment,i),f=!1},d(i){P(e,i)}}}const U={title:"How.This.Blog.Developed",description:"How.This.Blog.Developed",date:"2024-7-22",categories:["sveltekit","optimization"],published:!0};function N(h,e,f){return h.$$set=u=>{f(0,e=H(H({},e),z(u)))},e=z(e),[e]}class X extends G{constructor(e){super(),B(this,e,N,J,k,{})}}export{X as default,U as metadata};
